{% extends "base.html" %}

{% block title %}{{ t('cluster_frames.title', index=cluster_index + 1) }}{% endblock %}

{% block content %}
<div class="page-header">
    <a href="/video/{{ video_id }}" class="back-link">&larr; {{ t('cluster_frames.back_to_clusters') }}</a>
    <h1 id="pageTitle"><span id="clusterDisplayName">{{ t('clusters.person_label', index=cluster_index + 1) }}</span> &middot; <span id="frameCount">--</span> {{ t('video_detail.clusters.frames_other') }}</h1>
</div>

<!-- Cluster Info Section -->
<section class="section cluster-info-section">
    <div class="section-header">
        <div class="section-title-row">
            <h2>
                <span class="section-icon">&#9998;</span>
                {{ t('cluster_frames.info_title') }}
            </h2>
        </div>
    </div>
    <div class="cluster-info-form">
        <div class="form-row">
            <div class="form-group">
                <label for="clusterLabel">{{ t('cluster_frames.name_label') }} <span class="info-tooltip" data-tooltip="{{ t('cluster_frames.name_tooltip') }}">&#9432;</span></label>
                <input type="text" id="clusterLabel" placeholder="{{ t('cluster_frames.name_placeholder') }}" maxlength="128">
            </div>
        </div>
        <div class="form-group">
            <label for="clusterDescription">{{ t('cluster_frames.notes_label') }} <span class="info-tooltip" data-tooltip="{{ t('cluster_frames.notes_tooltip') }}">&#9432;</span></label>
            <textarea id="clusterDescription" rows="2" maxlength="2000"
                      placeholder="{{ t('cluster_frames.notes_placeholder') }}"></textarea>
        </div>
        <div class="form-actions">
            <button class="btn btn-save btn-small" id="btnSaveClusterInfo" onclick="saveClusterInfo()" disabled>
                &#10003; {{ t('cluster_frames.save_changes') }}
            </button>
            <span class="save-status" id="saveStatus"></span>
        </div>
    </div>
</section>

<div class="frames-manager">
    <!-- Reference Frames Section -->
    <section class="section frames-section references-section">
        <div class="section-header">
            <div class="section-title-row">
                <h2>
                    <span class="section-icon">&#9889;</span>
                    {{ t('cluster_frames.references_title') }}
                    <span class="reference-counter" id="refCounter">(--/{{ max_refs }})</span>
                    <span class="custom-badge hidden" id="customBadge" title="{{ t('cluster_frames.references_custom_tooltip') }}">{{ t('cluster_frames.references_custom') }}</span>
                </h2>
                <button class="info-btn" onclick="showInfoModal('references')" title="{{ t('common.info_tooltip') }}">&#9432;</button>
            </div>
            <div class="section-actions">
                <button class="btn btn-secondary btn-small" onclick="showResetModal()" id="btnReset">
                    &#8634; {{ t('cluster_frames.reset_default') }}
                </button>
            </div>
        </div>

        <p class="section-description">
            {{ t('cluster_frames.references_description') }}
        </p>

        <div class="frames-grid reference-frames-grid" id="referenceFramesGrid">
            <div class="loading">{{ t('cluster_frames.loading_refs') }}</div>
        </div>

        <p class="section-hint">
            <span class="hint-icon">&#128161;</span>
            {{ t('cluster_frames.references_hint') }}
        </p>
    </section>

    <!-- Library Frames Section -->
    <section class="section frames-section library-section">
        <div class="section-header">
            <div class="section-title-row">
                <h2>
                    <span class="section-icon">&#128193;</span>
                    {{ t('cluster_frames.library_title') }}
                </h2>
                <button class="info-btn" onclick="showInfoModal('library')" title="{{ t('common.info_tooltip') }}">&#9432;</button>
            </div>
            <div class="section-actions">
                <span class="selection-info" id="librarySelectionInfo">0 {{ t('common.none') }}</span>
            </div>
        </div>

        <div class="library-toolbar">
            <div class="toolbar-left">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="selectAllLibrary" onchange="toggleSelectAll()">
                    <span>{{ t('cluster_frames.library_select_all') }}</span>
                </label>
                <div class="filter-group">
                    <label for="frameSource">{{ t('cluster_frames.library_show') }}</label>
                    <select id="frameSource" onchange="changeFrameSource()">
                        <option value="cluster">{{ t('cluster_frames.library_cluster_frames') }}</option>
                        <option value="all">{{ t('cluster_frames.library_all_frames') }}</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="groupByMode">{{ t('cluster_frames.library_group_by') }}</label>
                    <select id="groupByMode" onchange="changeGroupByMode()">
                        <option value="none" selected>{{ t('cluster_frames.library_group_face') }}</option>
                        <option value="scene">{{ t('cluster_frames.library_group_scene') }}</option>
                    </select>
                </div>
            </div>
            <div class="toolbar-actions">
                <button class="btn btn-secondary btn-small" id="btnAddToRefs" onclick="addSelectedToReferences()" disabled>
                    &#10133; {{ t('cluster_frames.add_to_refs') }}
                </button>
                <button class="btn btn-primary btn-small hidden" id="btnAddToCluster" onclick="addSelectedToCluster()" disabled>
                    &#10133; {{ t('cluster_frames.add_to_cluster') }}
                </button>
                <button class="btn btn-danger btn-small" id="btnDeleteFrames" onclick="showDeleteModal()" disabled>
                    &#128465; {{ t('cluster_frames.delete_frames') }} (<span id="deleteCount">0</span>)
                </button>
            </div>
        </div>

        <div class="frames-grid library-frames-grid" id="libraryFramesGrid">
            <div class="loading">{{ t('cluster_frames.loading_frames') }}</div>
        </div>
    </section>
</div>

<!-- Info Modal: References -->
<div id="infoModalReferences" class="modal-overlay">
    <div class="modal-dialog modal-info modal-wide">
        <div class="modal-header">
            <span class="modal-icon">&#9432;</span>
            <span class="modal-title">{{ t('create_cluster.info_refs_title') }}</span>
        </div>
        <div class="modal-body">
            <p>{{ t('create_cluster.info_refs_text') }}</p>
            <ul class="info-list">
                <li>{{ t('create_cluster.info_refs_list1', max=max_refs) }}</li>
                <li>{{ t('create_cluster.info_refs_list2') }}</li>
                <li>{{ t('create_cluster.info_refs_list3') }}</li>
            </ul>
            <div class="info-box">
                <strong>&#8634; {{ t('cluster_frames.reset_default') }}:</strong> {{ t('cluster_frames.reset_hint') }}
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="closeModal('infoModalReferences')">{{ t('create_cluster.understood') }}</button>
        </div>
    </div>
</div>

<!-- Info Modal: Library -->
<div id="infoModalLibrary" class="modal-overlay">
    <div class="modal-dialog modal-info modal-wide">
        <div class="modal-header">
            <span class="modal-icon">&#9432;</span>
            <span class="modal-title">{{ t('create_cluster.info_library_title') }}</span>
        </div>
        <div class="modal-body">
            <p>{{ t('create_cluster.info_library_text') }}</p>
            <h4>{{ t('cluster_frames.library_show') }}:</h4>
            <ul class="info-list">
                <li><strong>{{ t('cluster_frames.library_cluster_frames') }}:</strong> {{ t('cluster_frames.library_cluster_desc') }}</li>
                <li><strong>{{ t('cluster_frames.library_all_frames') }}:</strong> {{ t('cluster_frames.library_all_desc') }}</li>
            </ul>
            <h4>{{ t('create_cluster.info_library_actions') }}:</h4>
            <ul class="info-list">
                <li><strong>&#10133; {{ t('cluster_frames.add_to_refs') }}:</strong> {{ t('create_cluster.info_library_refs', max=max_refs) }}</li>
                <li><strong>&#10133; {{ t('cluster_frames.add_to_cluster') }}:</strong> {{ t('create_cluster.info_library_cluster') }}</li>
                <li><strong>&#128465; {{ t('cluster_frames.delete_frames') }}:</strong> {{ t('cluster_frames.delete_frames_desc') }}</li>
            </ul>
            <div class="info-box info-box-hint">
                <strong>&#128161;</strong> {{ t('create_cluster.info_library_hint') }}
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="closeModal('infoModalLibrary')">{{ t('create_cluster.understood') }}</button>
        </div>
    </div>
</div>

<!-- Reset Confirmation Modal -->
<div id="resetModal" class="modal-overlay">
    <div class="modal-dialog modal-info">
        <div class="modal-header">
            <span class="modal-icon">&#8634;</span>
            <span class="modal-title">{{ t('cluster_frames.reset_title') }}</span>
        </div>
        <div class="modal-body">
            <p>{{ t('cluster_frames.reset_message', max=max_refs) }}</p>
            <div class="info-box info-box-hint">
                <strong>&#128161;</strong> {{ t('cluster_frames.reset_hint') }}
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-cancel" onclick="closeModal('resetModal')">{{ t('common.cancel') }}</button>
            <button class="btn btn-confirm" onclick="confirmReset()">&#8634; {{ t('cluster_frames.reset_default') }}</button>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="deleteModal" class="modal-overlay">
    <div class="modal-dialog modal-danger">
        <div class="modal-header">
            <span class="modal-icon">&#128465;</span>
            <span class="modal-title">{{ t('cluster_frames.delete_title', count='<span id="deleteModalCount">0</span>') | safe }}</span>
        </div>
        <div class="modal-body">
            <p>{{ t('cluster_frames.delete_message') }}</p>
            <ul class="delete-effects-list">
                <li><span class="icon">&#128193;</span> {{ t('cluster_frames.delete_files') }}</li>
                <li><span class="icon">&#128451;</span> {{ t('cluster_frames.delete_records') }}</li>
                <li><span class="icon">&#9889;</span> {{ t('cluster_frames.delete_refs') }}</li>
            </ul>
            <div class="info-box info-box-warning">
                <strong>&#9888; {{ t('cluster_frames.delete_warning') }}</strong>
            </div>
            <div class="info-box info-box-hint">
                <strong>&#128161;</strong> {{ t('cluster_frames.delete_hint') }}
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-cancel" onclick="closeModal('deleteModal')">{{ t('common.cancel') }}</button>
            <button class="btn btn-confirm" onclick="confirmDelete()">&#128465; {{ t('common.delete') }} (<span id="deleteModalCountBtn">0</span>)</button>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
    const videoId = {{ video_id }};
    const clusterIndex = {{ cluster_index }};
    const MAX_REFS = {{ max_refs }};
    const viewMode = "{{ view_mode }}";

    // =========================================================================
    // STATE
    // =========================================================================
    let referenceFrames = [];           // From DB (marked as AI references)
    let libraryFrames = [];             // From DB (all other frames in cluster)
    let allVideoFrames = [];            // All frames from disk (for "all" mode)
    let allFramesByFilename = new Map(); // filename â†’ frame object (fast lookup)
    let clusterFilenames = new Set();   // Filenames of frames in current cluster
    let selectedLibraryIds = new Set(); // Track by frame ID (cluster mode)
    let selectedFilenames = new Set();  // Track by filename (all mode)
    let isCustomSelection = false;
    let currentSource = 'cluster';      // 'cluster' or 'all'
    let groupByMode = 'none';           // 'none' or 'scene' (grouping mode)

    // Cluster info state
    let clusterInfo = { label: null, description: null };
    let originalClusterInfo = { label: null, description: null };

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    document.addEventListener('DOMContentLoaded', () => {
        loadClusterInfo();
        loadFrames();
        setupEventListeners();
        setupClusterInfoListeners();
    });

    function setupClusterInfoListeners() {
        const labelInput = document.getElementById('clusterLabel');
        const descInput = document.getElementById('clusterDescription');

        labelInput.addEventListener('input', checkClusterInfoChanged);
        descInput.addEventListener('input', checkClusterInfoChanged);
    }

    function checkClusterInfoChanged() {
        const labelInput = document.getElementById('clusterLabel');
        const descInput = document.getElementById('clusterDescription');
        const saveBtn = document.getElementById('btnSaveClusterInfo');

        const currentLabel = labelInput.value.trim();
        const currentDesc = descInput.value.trim();

        const hasChanges = currentLabel !== (originalClusterInfo.label || '') ||
                          currentDesc !== (originalClusterInfo.description || '');

        saveBtn.disabled = !hasChanges;
    }

    async function loadClusterInfo() {
        try {
            const response = await fetch(`/api/analysis/${videoId}/clusters?view_mode=${viewMode}`);
            if (!response.ok) throw new Error('Error loading cluster info');

            const data = await response.json();
            const cluster = data.clusters.find(c => c.cluster_index === clusterIndex);

            if (cluster) {
                clusterInfo = {
                    label: cluster.label || null,
                    description: cluster.description || null
                };
                originalClusterInfo = { ...clusterInfo };

                // Update UI
                document.getElementById('clusterLabel').value = cluster.label || '';
                document.getElementById('clusterDescription').value = cluster.description || '';

                // Update page title
                const displayName = cluster.label || t('clusters.person_label', {index: clusterIndex + 1});
                document.getElementById('clusterDisplayName').textContent = displayName;
                document.title = t('cluster_frames.title', {name: displayName});
            }
        } catch (error) {
            console.error('Error loading cluster info:', error);
        }
    }

    async function saveClusterInfo() {
        const labelInput = document.getElementById('clusterLabel');
        const descInput = document.getElementById('clusterDescription');
        const saveBtn = document.getElementById('btnSaveClusterInfo');
        const saveStatus = document.getElementById('saveStatus');

        const newLabel = labelInput.value.trim() || null;
        const newDesc = descInput.value.trim() || null;

        saveBtn.disabled = true;
        saveStatus.textContent = t('cluster_frames.saving');
        saveStatus.className = 'save-status saving';

        try {
            const response = await fetch(`/api/analysis/${videoId}/clusters/${clusterIndex}?view_mode=${viewMode}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    label: newLabel,
                    description: newDesc
                })
            });

            if (!response.ok) throw new Error('Error saving cluster info');

            // Update state
            originalClusterInfo = { label: newLabel, description: newDesc };
            clusterInfo = { ...originalClusterInfo };

            // Update page title
            const displayName = newLabel || t('video_detail.clusters.person', {index: clusterIndex + 1});
            document.getElementById('clusterDisplayName').textContent = displayName;
            document.title = t('cluster_frames.title', {name: displayName});

            saveStatus.innerHTML = '&#10003; ' + t('cluster_frames.saved');
            saveStatus.className = 'save-status saved';

            setTimeout(() => {
                saveStatus.textContent = '';
                saveStatus.className = 'save-status';
            }, 2000);

        } catch (error) {
            saveStatus.textContent = t('errors.save_failed');
            saveStatus.className = 'save-status error';
            saveBtn.disabled = false;
            console.error('Error saving cluster info:', error);
        }
    }

    function setupEventListeners() {
        // Event delegation for library grid (handles both cluster and all modes)
        document.getElementById('libraryFramesGrid')
            .addEventListener('click', handleLibraryGridClick);
    }

    async function loadFrames() {
        try {
            // Load ALL frames from DB (now contains all frames, not just 20)
            const response = await fetch(`/api/analysis/${videoId}/clusters/${clusterIndex}/frames/all?view_mode=${viewMode}`);
            if (!response.ok) throw new Error('Error loading frames');

            const data = await response.json();

            referenceFrames = data.reference_frames;
            libraryFrames = data.library_frames;
            isCustomSelection = data.is_custom_selection;

            // Build set of cluster filenames for comparison (extract from path)
            clusterFilenames.clear();
            referenceFrames.forEach(f => {
                const filename = f.frame_path.split(/[/\\]/).pop();
                clusterFilenames.add(filename);
            });
            libraryFrames.forEach(f => {
                const filename = f.frame_path.split(/[/\\]/).pop();
                clusterFilenames.add(filename);
            });

            renderReferenceFrames();
            renderLibraryFrames();
            updateCounters();

        } catch (error) {
            console.error('Error loading frames:', error);
            document.getElementById('referenceFramesGrid').innerHTML =
                `<div class="error">${t('errors.load_frames')}: ${error.message}</div>`;
            document.getElementById('libraryFramesGrid').innerHTML =
                `<div class="error">${t('errors.load_frames')}: ${error.message}</div>`;
        }
    }

    async function loadAllVideoFrames() {
        try {
            const response = await fetch(`/api/analysis/${videoId}/frames/all?include_assigned=true`);
            if (!response.ok) throw new Error('Error loading all frames');

            const data = await response.json();
            allVideoFrames = data.frames;

            // Build lookup map for O(1) access by filename
            allFramesByFilename.clear();
            allVideoFrames.forEach(frame => {
                allFramesByFilename.set(frame.filename, frame);
            });

        } catch (error) {
            console.error('Error loading all frames:', error);
            allVideoFrames = [];
        }
    }

    async function changeFrameSource() {
        const source = document.getElementById('frameSource').value;
        currentSource = source;

        // Clear selections when changing source
        selectedLibraryIds.clear();
        selectedFilenames.clear();

        if (source === 'all') {
            // Load all video frames if not already loaded
            if (allVideoFrames.length === 0) {
                document.getElementById('libraryFramesGrid').innerHTML = `<div class="loading">${t('cluster_frames.loading_all')}</div>`;
                await loadAllVideoFrames();
            }
            renderAllFrames();
        } else {
            renderLibraryFrames();
        }

        updateCounters();
    }

    function changeGroupByMode() {
        groupByMode = document.getElementById('groupByMode').value;

        // Re-render current view with new grouping mode
        if (currentSource === 'all') {
            renderAllFrames();
        } else {
            renderLibraryFrames();
        }
    }

    // =========================================================================
    // SCENE GROUPING FUNCTIONS
    // =========================================================================

    function extractSceneNumber(framePath) {
        // Extract scene number from path like ".../scene_000_frame_000007.jpg"
        if (!framePath) return null;
        const filename = framePath.split(/[/\\]/).pop();
        const match = filename.match(/scene_(\d+)/);
        return match ? parseInt(match[1]) : null;
    }

    function groupFramesByScene(frames, getPath) {
        // Group frames by scene number
        const grouped = {};
        frames.forEach(frame => {
            const path = getPath ? getPath(frame) : frame.frame_path;
            const sceneNum = extractSceneNumber(path);
            const key = sceneNum !== null ? sceneNum : 'unknown';

            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(frame);
        });
        return grouped;
    }

    function renderGroupedFrames(grouped, createCardFn) {
        // Sort scene keys numerically
        const sortedKeys = Object.keys(grouped).sort((a, b) => {
            if (a === 'unknown') return 1;
            if (b === 'unknown') return -1;
            return parseInt(a) - parseInt(b);
        });

        let html = '';
        sortedKeys.forEach(sceneKey => {
            const frames = grouped[sceneKey];
            const sceneLabel = sceneKey === 'unknown' ? t('cluster_frames.scene_unknown') : t('cluster_frames.scene_label', {num: sceneKey});
            const frameCount = frames.length;

            html += `
                <div class="scene-group">
                    <div class="scene-group-header">
                        <span class="scene-group-title">${sceneLabel}</span>
                        <span class="scene-group-count">${t('clusters.frame_count_other', {count: frameCount})}</span>
                    </div>
                    <div class="scene-group-frames">
                        ${frames.map(frame => createCardFn(frame)).join('')}
                    </div>
                </div>
            `;
        });

        return html;
    }

    // =========================================================================
    // EVENT HANDLERS (delegated)
    // =========================================================================

    function handleLibraryGridClick(e) {
        const card = e.target.closest('.library-frame-card');
        if (!card) return;

        // Prevent double-toggle if clicking checkbox directly
        if (e.target.tagName === 'INPUT') {
            e.stopPropagation();
        }

        if (currentSource === 'cluster') {
            // Cluster mode: use frame ID
            const frameId = card.dataset.frameId;
            if (frameId) {
                toggleFrameSelection(parseInt(frameId));
            }
        } else {
            // All frames mode: use filename
            const filename = card.dataset.filename;
            if (filename) {
                toggleAllFrameSelection(filename);
            }
        }
    }

    // =========================================================================
    // RENDERING
    // =========================================================================

    function renderReferenceFrames() {
        const grid = document.getElementById('referenceFramesGrid');

        if (referenceFrames.length === 0) {
            grid.innerHTML = `<p class="empty-message">${t('empty_state.no_references')}</p>`;
            return;
        }

        grid.innerHTML = referenceFrames.map(frame => createReferenceFrameCard(frame)).join('');
    }

    function renderLibraryFrames() {
        const grid = document.getElementById('libraryFramesGrid');

        if (libraryFrames.length === 0) {
            grid.innerHTML = `<p class="empty-message">${t('empty_state.no_more_frames')}</p>`;
            return;
        }

        if (groupByMode === 'scene') {
            // Group by scene
            const grouped = groupFramesByScene(libraryFrames, f => f.frame_path);
            grid.innerHTML = renderGroupedFrames(grouped, createLibraryFrameCard);
        } else {
            // Flat list (original behavior)
            grid.innerHTML = libraryFrames.map(frame => createLibraryFrameCard(frame)).join('');
        }
    }

    function renderAllFrames() {
        const grid = document.getElementById('libraryFramesGrid');

        // Filter out frames already in this cluster
        const availableFrames = allVideoFrames.filter(f => !clusterFilenames.has(f.filename));

        if (availableFrames.length === 0) {
            grid.innerHTML = `<p class="empty-message">${t('empty_state.no_frames_filter')}</p>`;
            return;
        }

        if (groupByMode === 'scene') {
            // Group by scene (use filename for allVideoFrames)
            const grouped = groupFramesByScene(availableFrames, f => f.filename);
            grid.innerHTML = renderGroupedFrames(grouped, createAllFrameCard);
        } else {
            // Flat list (original behavior)
            grid.innerHTML = availableFrames.map(frame => createAllFrameCard(frame)).join('');
        }
    }

    function createAllFrameCard(frame) {
        const qualityScore = (frame.quality_score || 0) / 10;
        const qualityClass = getQualityClass(frame.quality_score);
        const expressionIcon = getExpressionIcon(frame.expression);
        const isSelected = selectedFilenames.has(frame.filename);
        const sceneInfo = extractSceneInfo(frame.filename);
        const isInOtherCluster = frame.cluster_id !== null;

        let statusIcon = '';
        let statusClass = '';
        if (isInOtherCluster) {
            statusClass = 'in-other-cluster';
            statusIcon = `<span class="frame-status-icon" title="${t('cluster_frames.in_other_cluster', {index: frame.cluster_index + 1})}">&#128100;</span>`;
        }

        return `
            <div class="frame-card library-frame-card ${isSelected ? 'selected' : ''} ${statusClass}"
                 data-filename="${frame.filename}">
                <div class="frame-checkbox">
                    <input type="checkbox" ${isSelected ? 'checked' : ''}>
                </div>
                ${statusIcon}
                <img src="/api/analysis/${videoId}/frames/${encodeURIComponent(frame.filename)}/image"
                     alt="${frame.filename}"
                     loading="lazy"
                     onerror="this.src='/static/img/placeholder.svg'">
                <div class="frame-info">
                    <div class="quality-bar ${qualityClass}">
                        <div class="quality-fill" style="width: ${frame.quality_score || 0}%"></div>
                    </div>
                    <div class="frame-meta">
                        <span class="quality-score" title="${t('cluster_frames.quality_score')}">${qualityScore.toFixed(1)}</span>
                        <span class="scene-info" title="${t('cluster_frames.scene_frame')}">${sceneInfo}</span>
                        <span class="expression-icon" title="${frame.expression || t('common.unknown')}">${expressionIcon}</span>
                    </div>
                </div>
            </div>
        `;
    }

    function createReferenceFrameCard(frame) {
        const qualityScore = (frame.quality_score || 0) / 10;
        const qualityClass = getQualityClass(frame.quality_score);
        const expressionIcon = getExpressionIcon(frame.expression);

        return `
            <div class="frame-card reference-frame-card" data-frame-id="${frame.id}">
                <button class="frame-remove-btn" onclick="removeFromReferences(${frame.id})" title="${t('cluster_frames.remove_reference')}">
                    &times;
                </button>
                <img src="/api/analysis/${videoId}/clusters/${clusterIndex}/frames/${frame.id}/image"
                     alt="Frame ${frame.id}"
                     loading="lazy"
                     onerror="this.src='/static/img/placeholder.svg'">
                <div class="frame-info">
                    <div class="quality-bar ${qualityClass}">
                        <div class="quality-fill" style="width: ${frame.quality_score || 0}%"></div>
                    </div>
                    <div class="frame-meta">
                        <span class="quality-score" title="${t('cluster_frames.quality_score')}">${qualityScore.toFixed(1)}</span>
                        <span class="expression-icon" title="${frame.expression || t('common.unknown')}">${expressionIcon}</span>
                    </div>
                </div>
            </div>
        `;
    }

    function createLibraryFrameCard(frame) {
        const qualityScore = (frame.quality_score || 0) / 10;
        const qualityClass = getQualityClass(frame.quality_score);
        const expressionIcon = getExpressionIcon(frame.expression);
        const isSelected = selectedLibraryIds.has(frame.id);
        const sceneInfo = extractSceneInfo(frame.frame_path);

        return `
            <div class="frame-card library-frame-card ${isSelected ? 'selected' : ''}"
                 data-frame-id="${frame.id}">
                <div class="frame-checkbox">
                    <input type="checkbox" ${isSelected ? 'checked' : ''}>
                </div>
                <img src="/api/analysis/${videoId}/clusters/${clusterIndex}/frames/${frame.id}/image"
                     alt="Frame ${frame.id}"
                     loading="lazy"
                     onerror="this.src='/static/img/placeholder.svg'">
                <div class="frame-info">
                    <div class="quality-bar ${qualityClass}">
                        <div class="quality-fill" style="width: ${frame.quality_score || 0}%"></div>
                    </div>
                    <div class="frame-meta">
                        <span class="quality-score" title="${t('cluster_frames.quality_score')}">${qualityScore.toFixed(1)}</span>
                        <span class="scene-info" title="${t('cluster_frames.scene_frame')}">${sceneInfo}</span>
                        <span class="expression-icon" title="${frame.expression || t('common.unknown')}">${expressionIcon}</span>
                    </div>
                </div>
            </div>
        `;
    }

    function extractSceneInfo(framePath) {
        // Extract scene and frame number from path like ".../scene_000_frame_000007.jpg"
        if (!framePath) return '';
        const filename = framePath.split(/[/\\]/).pop();
        const match = filename.match(/scene_(\d+)_frame_(\d+)/);
        if (match) {
            return `S${parseInt(match[1])}:F${parseInt(match[2])}`;
        }
        return '';
    }

    function getQualityClass(score) {
        if (score >= 90) return 'quality-excellent';
        if (score >= 75) return 'quality-good';
        if (score >= 60) return 'quality-fair';
        if (score >= 40) return 'quality-poor';
        return 'quality-bad';
    }

    function getExpressionIcon(expression) {
        const icons = {
            'smiling': '&#128522;',      // ðŸ˜Š
            'neutral': '&#128528;',       // ðŸ˜
            'mouth_closed': '&#128566;',  // ðŸ˜¶
            'mouth_open': '&#128558;'     // ðŸ˜®
        };
        return icons[expression] || '&#128528;';
    }

    function updateCounters() {
        // Frame count in title
        const total = referenceFrames.length + libraryFrames.length;
        document.getElementById('frameCount').textContent = total;

        // Reference counter
        document.getElementById('refCounter').textContent = `(${referenceFrames.length}/${MAX_REFS})`;

        // Custom badge
        const customBadge = document.getElementById('customBadge');
        if (isCustomSelection) {
            customBadge.classList.remove('hidden');
        } else {
            customBadge.classList.add('hidden');
        }

        // Get selection count based on current source
        const selCount = currentSource === 'cluster' ? selectedLibraryIds.size : selectedFilenames.size;

        // Library selection info
        document.getElementById('librarySelectionInfo').textContent =
            t('selection.selected_count', {count: selCount});

        // Button states
        const btnAddToRefs = document.getElementById('btnAddToRefs');
        const btnAddToCluster = document.getElementById('btnAddToCluster');
        const btnDeleteFrames = document.getElementById('btnDeleteFrames');
        const isFull = referenceFrames.length >= MAX_REFS;

        if (currentSource === 'cluster') {
            // Cluster mode: show add to refs, delete; hide add to cluster
            btnAddToRefs.classList.remove('hidden');
            btnAddToRefs.disabled = selCount === 0 || isFull;
            btnAddToCluster.classList.add('hidden');
            btnDeleteFrames.classList.remove('hidden');
            btnDeleteFrames.disabled = selCount === 0;
            document.getElementById('deleteCount').textContent = selCount;
        } else {
            // All frames mode: show add to cluster; hide add to refs, delete
            btnAddToRefs.classList.add('hidden');
            btnAddToCluster.classList.remove('hidden');
            btnAddToCluster.disabled = selCount === 0;
            btnDeleteFrames.classList.add('hidden');
        }

        // Dynamic tooltip for disabled button
        if (isFull) {
            btnAddToRefs.title = t('errors.max_references_reached');
        } else if (selCount === 0) {
            btnAddToRefs.title = t('empty_state.select_frames_hint');
        } else {
            btnAddToRefs.title = '';
        }

        // Select all checkbox state
        const selectAllCb = document.getElementById('selectAllLibrary');
        if (currentSource === 'cluster') {
            selectAllCb.checked = selCount === libraryFrames.length && selCount > 0;
            selectAllCb.indeterminate = selCount > 0 && selCount < libraryFrames.length;
        } else {
            const availableCount = allVideoFrames.filter(f => !clusterFilenames.has(f.filename)).length;
            selectAllCb.checked = selCount === availableCount && selCount > 0;
            selectAllCb.indeterminate = selCount > 0 && selCount < availableCount;
        }
    }

    // =========================================================================
    // SELECTION
    // =========================================================================

    function toggleFrameSelection(frameId) {
        if (selectedLibraryIds.has(frameId)) {
            selectedLibraryIds.delete(frameId);
        } else {
            selectedLibraryIds.add(frameId);
        }

        // Selective DOM update instead of full re-render
        updateClusterFrameCardState(frameId);
        updateCounters();
    }

    function updateClusterFrameCardState(frameId) {
        const card = document.querySelector(`.library-frame-card[data-frame-id="${frameId}"]`);
        if (!card) return;

        const isSelected = selectedLibraryIds.has(frameId);
        card.classList.toggle('selected', isSelected);

        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox) checkbox.checked = isSelected;
    }

    function toggleAllFrameSelection(filename) {
        if (selectedFilenames.has(filename)) {
            selectedFilenames.delete(filename);
        } else {
            selectedFilenames.add(filename);
        }

        // Selective DOM update instead of full re-render
        updateAllFrameCardState(filename);
        updateCounters();
    }

    function updateAllFrameCardState(filename) {
        const card = document.querySelector(
            `.library-frame-card[data-filename="${CSS.escape(filename)}"]`
        );
        if (!card) return;

        const isSelected = selectedFilenames.has(filename);
        card.classList.toggle('selected', isSelected);

        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox) checkbox.checked = isSelected;
    }

    function toggleSelectAll() {
        const selectAllCb = document.getElementById('selectAllLibrary');

        if (currentSource === 'cluster') {
            if (selectAllCb.checked) {
                libraryFrames.forEach(f => selectedLibraryIds.add(f.id));
            } else {
                selectedLibraryIds.clear();
            }
            renderLibraryFrames();
        } else {
            const availableFrames = allVideoFrames.filter(f => !clusterFilenames.has(f.filename));
            if (selectAllCb.checked) {
                availableFrames.forEach(f => selectedFilenames.add(f.filename));
            } else {
                selectedFilenames.clear();
            }
            renderAllFrames();
        }

        updateCounters();
    }

    // =========================================================================
    // ACTIONS
    // =========================================================================

    async function removeFromReferences(frameId) {
        try {
            const response = await fetch(
                `/api/analysis/${videoId}/clusters/${clusterIndex}/frames/references/${frameId}?view_mode=${viewMode}`,
                { method: 'DELETE' }
            );

            if (!response.ok) throw new Error('Error removing reference');

            ThumbnailApp.showToast(t('cluster_frames.reference_removed'), 'success');
            loadFrames();

        } catch (error) {
            ThumbnailApp.showToast(t('common.error') + ': ' + error.message, 'error');
        }
    }

    async function addSelectedToReferences() {
        if (selectedLibraryIds.size === 0) return;

        const frameIds = Array.from(selectedLibraryIds);

        try {
            const response = await fetch(
                `/api/analysis/${videoId}/clusters/${clusterIndex}/frames/references/add?view_mode=${viewMode}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ frame_ids: frameIds })
                }
            );

            if (!response.ok) throw new Error('Error adding references');

            const data = await response.json();

            if (data.added > 0) {
                ThumbnailApp.showToast(t('cluster_frames.frames_added_refs', {count: data.added}), 'success');
            }
            if (data.skipped > 0) {
                ThumbnailApp.showToast(t('cluster_frames.frames_skipped_max', {count: data.skipped, max: MAX_REFS}), 'warning');
            }

            selectedLibraryIds.clear();
            loadFrames();

        } catch (error) {
            ThumbnailApp.showToast(t('common.error') + ': ' + error.message, 'error');
        }
    }

    // Helper function to convert filenames to paths for API calls
    function filenamesToPaths(filenames) {
        return Array.from(filenames)
            .map(filename => allFramesByFilename.get(filename)?.path)
            .filter(Boolean);
    }

    async function addSelectedToCluster() {
        if (selectedFilenames.size === 0) return;

        // Convert filenames to paths for the API
        const framePaths = filenamesToPaths(selectedFilenames);

        if (framePaths.length === 0) {
            ThumbnailApp.showToast(t('errors.frames_not_found'), 'error');
            return;
        }

        try {
            const response = await fetch(
                `/api/analysis/${videoId}/clusters/${clusterIndex}/frames/add?view_mode=${viewMode}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ frame_paths: framePaths })
                }
            );

            if (!response.ok) throw new Error('Error adding frames to cluster');

            const data = await response.json();

            if (data.added > 0) {
                ThumbnailApp.showToast(t('cluster_frames.frames_added_cluster', {count: data.added}), 'success');
            }
            if (data.skipped > 0) {
                ThumbnailApp.showToast(t('cluster_frames.frames_already_in', {count: data.skipped}), 'info');
            }

            // Clear selection and reload
            selectedFilenames.clear();

            // Reload frames to update cluster filenames
            await loadFrames();

            // Re-render all frames view
            if (currentSource === 'all') {
                renderAllFrames();
            }

            // Update page title with new frame count
            const newTotal = referenceFrames.length + libraryFrames.length;
            document.getElementById('frameCount').textContent = newTotal;

            updateCounters();

        } catch (error) {
            ThumbnailApp.showToast(t('common.error') + ': ' + error.message, 'error');
        }
    }

    // =========================================================================
    // MODALS
    // =========================================================================

    function showInfoModal(type) {
        const modalId = type === 'references' ? 'infoModalReferences' : 'infoModalLibrary';
        document.getElementById(modalId).classList.add('visible');
    }

    function showResetModal() {
        document.getElementById('resetModal').classList.add('visible');
    }

    function showDeleteModal() {
        if (selectedLibraryIds.size === 0) return;

        document.getElementById('deleteModalCount').textContent = selectedLibraryIds.size;
        document.getElementById('deleteModalCountBtn').textContent = selectedLibraryIds.size;
        document.getElementById('deleteModal').classList.add('visible');
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('visible');
    }

    async function confirmReset() {
        closeModal('resetModal');

        try {
            const response = await fetch(
                `/api/analysis/${videoId}/clusters/${clusterIndex}/frames/references/reset?view_mode=${viewMode}`,
                { method: 'POST' }
            );

            if (!response.ok) throw new Error('Error resetting references');

            ThumbnailApp.showToast(t('cluster_frames.reset_success'), 'success');
            loadFrames();

        } catch (error) {
            ThumbnailApp.showToast(t('common.error') + ': ' + error.message, 'error');
        }
    }

    async function confirmDelete() {
        closeModal('deleteModal');

        if (selectedLibraryIds.size === 0) return;

        const frameIds = Array.from(selectedLibraryIds);

        try {
            const response = await fetch(
                `/api/analysis/${videoId}/clusters/${clusterIndex}/frames?view_mode=${viewMode}`,
                {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ frame_ids: frameIds })
                }
            );

            if (!response.ok) throw new Error('Error deleting frames');

            const data = await response.json();

            ThumbnailApp.showToast(t('cluster_frames.delete_success', {count: data.deleted}), 'success');

            if (data.errors && data.errors.length > 0) {
                console.warn('Delete errors:', data.errors);
            }

            selectedLibraryIds.clear();
            loadFrames();

        } catch (error) {
            ThumbnailApp.showToast(t('common.error') + ': ' + error.message, 'error');
        }
    }

</script>
{% endblock %}
